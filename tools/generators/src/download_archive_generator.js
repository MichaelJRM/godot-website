import yaml from 'js-yaml';
import fs from 'fs';
import {COMMON_PLATFORM, generateLink, getDownloadSlugs, HOST} from './url_util.js';

const GENERATION_MESSAGE = 'Generated by /tools/generators/src/download_archive_generator !!! do not edit by hand !!!';
const HOSTS = [HOST.githubBuilds, HOST.github];
const EXPORT_PATH = 'download/archive';
const DATA_VERSIONS_PATH = 'data/versions.yml';
const HUGO_CONFIG_PATH = 'hugo.yml';

/**
 * @typedef {Object} Version
 * @property {string} name
 * @property {string} flavor
 * @property {string} release_version
 */

(function main() {
  const hugoConfigFile = loadHugoConfigFile();
  const supportedLanguages = hugoConfigFile.languages;
  const versions = loadVersions();
  const downloadPlatforms = {};
  const supportedLanguagesISO = Object.keys(supportedLanguages);
  for (const iso of supportedLanguagesISO) {
    downloadPlatforms[iso] = loadDownloadPlatforms(iso);
  }

  for (let i = 0; i < versions.length; i++) {
    const version = versions[i];

    // TODO: Translate title
    const frontmatter = {
      title: `Download Godot ${version.name} (${version.flavor}) - Godot Engine`,
      type: 'download/archive',
      name: version.name,
      flavor: version.flavor,
      featured: version.featured,
      release_date: convertDateToIsoFormat(version.release_date) ?? "",
      release_notes: version.release_notes ?? "",
    };

    if (!frontmatter.featured) {
      delete frontmatter.featured;
    }

    const links = generateVersionDownloadLinks(version, downloadPlatforms);
    frontmatter.primaryPlatforms = links.primary;

    for (const iso of supportedLanguagesISO) {
      const config = supportedLanguages[iso];
      if (config.disabled) continue;

      frontmatter.links = links.linksPerLanguage[iso];
      writeArchiveVersion(config.contentDir, version.name, version.flavor, frontmatter);
    }

    if (version.releases) {
      for (let j = 0; j < version.releases.length; j++) {
        const release = version.releases[j];

        frontmatter.title = `Download Godot ${version.name} (${release.name}) - Godot Engine`;
        frontmatter.flavor = release.name;
        frontmatter.featured = release.featured;
        frontmatter.release_date = convertDateToIsoFormat(release.release_date) ?? "";
        frontmatter.release_notes = release.release_notes ?? "";
        if (!frontmatter.featured) {
          delete frontmatter.featured;
        }

        const links = generateVersionDownloadLinks(
          {name: version.name, flavor: release.name},
          downloadPlatforms
        );
        frontmatter.primaryPlatforms = links.primary;

        for (const iso of supportedLanguagesISO) {
          const config = supportedLanguages[iso];
          if (config.disabled) continue;

          frontmatter.links = links.linksPerLanguage[iso];
          writeArchiveVersion(config.contentDir, version.name, release.name, frontmatter);
        }
      }
    }
  }
})();

/**
 * @typedef {Object} DownloadPlatforms
 * @property {string} iso
 * @property {DownloadPlatform[]} downloadPlatforms
 */

/**
 * @param {Version} version
 * @param {DownloadPlatforms} downloadPlatformsByIso
 * @return {Object}
 */
function generateVersionDownloadLinks(version, downloadPlatformsByIso) {
  const downloadPlatformsIsos = Object.keys(downloadPlatformsByIso);
  const downloadPlatformsMap = {};
  const linksPerLanguage = {};

  for (let i = 0; i < downloadPlatformsIsos.length; i++) {
    const iso = downloadPlatformsIsos[i];
    linksPerLanguage[iso] = {}
    const downloadPlatforms = downloadPlatformsByIso[iso];
    downloadPlatformsMap[iso] = {};

    for (let j = 0; j < downloadPlatforms.length; j++) {
      const platform = downloadPlatforms[j];
      downloadPlatformsMap[iso][platform.name] = platform;
    }
  }

  const downloadSlugs = getDownloadSlugs(version);
  const primary = [];

  function generateHosts(version, platform) {
    const hosts = {}

    for (let i = 0; i < HOSTS.length; i++) {
      const host = HOSTS[i];
      hosts[host] = {};
      hosts[host].regular = generateLink(version, platform, false, host);
      hosts[host].mono = generateLink(version, platform, true, host);
    }

    return hosts;
  }

  if (downloadSlugs.editor.primary) {
    const primaryPlatforms = Object.keys(downloadSlugs.editor.primary);
    for (let i = 0; i < primaryPlatforms.length; i++) {
      const platform = primaryPlatforms[i];
      primary.push(platform);
      const hosts = generateHosts(version, platform);
      extractHostsToAllLanguages(platform, hosts);
    }
  }

  if (downloadSlugs.editor.secondary) {
    const secondaryPlatforms = Object.keys(downloadSlugs.editor.secondary);
    for (let i = 0; i < secondaryPlatforms.length; i++) {
      const platform = secondaryPlatforms[i];
      const hosts = generateHosts(version, platform);
      extractHostsToAllLanguages(platform, hosts);
    }
  }

  if (downloadSlugs.extras) {
    const extras = Object.keys(downloadSlugs.extras);
    for (let i = 0; i < extras.length; i++) {
      const extra = extras[i];
      const hosts = generateHosts(version, extra);
      extractHostsToAllLanguages(extra, hosts);
    }
  }

  function extractHostsToAllLanguages(extra, hosts) {
    for (let i = 0; i < downloadPlatformsIsos.length; i++) {
      const iso = downloadPlatformsIsos[i];
      linksPerLanguage[iso][extra] = {
        ...downloadPlatformsMap[iso][extra],
      }
      linksPerLanguage[iso][extra].hosts = hosts;
    }
  }

  const templateHosts = generateHosts(version, COMMON_PLATFORM.templates);

  for (let i = 0; i < downloadPlatformsIsos.length; i++) {
    const iso = downloadPlatformsIsos[i];
    linksPerLanguage[iso][COMMON_PLATFORM.templates] = {
      ...downloadPlatformsMap[iso][COMMON_PLATFORM.templates],
    }
    linksPerLanguage[iso][COMMON_PLATFORM.templates].hosts = templateHosts;
  }

  // Templates always appear at the bottom
  primary.push(COMMON_PLATFORM.templates);

  return {
    linksPerLanguage,
    primary,
  };
}

function writeArchiveVersion(contentDir, name, flavor, data) {
  const yamlContent = yaml.dump(data, {forceQuotes: true});
  const frontmatter = `---\n# ${GENERATION_MESSAGE}\n${yamlContent}---`;
  fs.writeFile(`${contentDir}/${EXPORT_PATH}/${name}-${flavor}.md`, frontmatter, (err) => {
    if (err) throw err;
  });
}

function convertDateToIsoFormat(input) {
  const date = new Date(input);
  return date.toISOString().slice(0, 19) + "-00:00";
}

/**
 * @typedef {Object} DownloadPlatform
 * @property {string} name
 * @property {string} title
 * @property {string} caption
 * @property {string[]} tags
 */

/**
 * @property {string} iso
 * @returns {DownloadPlatform[]}
 */
function loadDownloadPlatforms(iso) {
  const fileContents = fs.readFileSync(`data/${iso}/download_platforms.yml`, 'utf8');
  return yaml.load(fileContents);
}

function loadVersions() {
  const fileContents = fs.readFileSync(DATA_VERSIONS_PATH, 'utf8');
  return yaml.load(fileContents);
}

function loadHugoConfigFile() {
  const fileContents = fs.readFileSync(HUGO_CONFIG_PATH, 'utf8');
  return yaml.load(fileContents);
}

